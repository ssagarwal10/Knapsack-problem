//SHUBHAM AGARWAL
//130

//DAA Assignment 4

//TITLE:Design and implement algorithm for the Knapsack problem.

//CODE:


#include <iostream>

using namespace std;
void mergesort(double [],double [],double [],int,int);
void merge(double[],double[],double[],int,int);
int main() {
	int i,n,m;
	cout<<"\nEnter the number of items\n";
	cin>>n;
	double weight[n],profit[n],ratio[n],wt=0,ans=0;

	cout<<"Enter the weight of the items\n";
	for(i=0;i<n;i++)
	{
		cin>>weight[i];
	}

	cout<<"Enter the profit of the items\n";
	for(i=0;i<n;i++)
		{
			cin>>profit[i];
		}
	cout<<"\nEnter the maximum weight that can be taken\n";
	cin>>m;
	for(i=0;i<n;i++)
	{
		ratio[i]=profit[i]/weight[i];
	}

	mergesort(ratio,weight,profit,0,n-1);

	for(i=0;i<n;i++)
	{
		ratio[i]=0;
	}

	for(i=0;i<n;i++)
	{
		if(wt+weight[i]<m)
		{
			ratio[i]=1;
			wt=wt+weight[i];
		}
		else
		{
			if(wt!=m)
			{
			ratio[i]=(m-wt)/weight[i];
			wt=m;
			}
			else
			{
				ratio[i]=0;
			}
		}
	}
	cout<<"\nThe instances used in fractional Knapsack are\n\n";
	cout<<"Weight\t\t";
	for(i=0;i<n;i++)
		{
			cout<<weight[i]<<"\t";

		}
	cout<<"\nProfit\t\t";
	for(i=0;i<n;i++)
		{
			cout<<profit[i]<<"\t";

		}
	cout<<"\nInstance\t";
	for(i=0;i<n;i++)
	{
		cout<<ratio[i]<<"\t";
		ans=ans+(profit[i]*ratio[i]);
	}

cout<<"\n\nThe maximum profit is "<<ans;

ans=0;
cout<<"\nThe instances used in 0-1 Knapsack are\n\n";
	cout<<"Weight\t\t";
	for(i=0;i<n;i++)
		{
			cout<<weight[i]<<"\t";

		}
	cout<<"\nProfit\t\t";
	for(i=0;i<n;i++)
		{
			cout<<profit[i]<<"\t";

		}
	cout<<"\nInstance\t";
	for(i=0;i<n;i++)
	{
		if(ratio[i]==1 || ratio[i]==0)
		{
		cout<<ratio[i]<<"\t";
		ans=ans+(profit[i]*ratio[i]);

		}
		else
		{
			cout<<"0\t";
			ans=ans+(profit[i]*0);

		}
	}

cout<<"\n\nThe maximum profit is "<<ans;


return 0;

}



void mergesort(double ratio[],double weight[],double profit[],int l, int h)
{
  if(h>l)
  {
    mergesort(ratio,weight,profit,l,(l+h)/2);
    mergesort(ratio,weight,profit,((l+h)/2)+1,h);
    merge(ratio,weight,profit,l,h);
  }
}

void merge(double ratio[],double weight[],double profit[], int l, int h)
{
    int b[h],a[h],c[h];
    int i,j,m,k=l;
    i=l;
    j=((l+h)/2)+1;
    m=j-1;
    while (i<=m && j<=h)
    {
      if(ratio[i]>ratio[j])
      {
        b[k]=ratio[i];
        a[k]=weight[i];
        c[k]=profit[i];
        i++;
      }
      else
      {
        b[k]=ratio[j];
        a[k]=weight[j];
        c[k]=profit[j];
        j++;
      }
      k++;
    }

    if(i>m)
    {
      while(j<=h)
      {
        b[k]=ratio[j];
        a[k]=weight[j];
        c[k]=profit[j];
        j++;
        k++;
      }
    }
    else
    {
      while(i<=m)
      {
        b[k]=ratio[i];
        a[k]=weight[i];
        c[k]=profit[i];
        i++;
        k++;
      }
    }
    k=l;
    while(k<=h)
    {
      ratio[k]=b[k];
      weight[k]=a[k];
      profit[k]=c[k];
      k++;
    }

}



//OUTPUT:


Enter the number of items
3
Enter the weight of the items
10
20
30
Enter the profit of the items
60
100
120

Enter the maximum weight that can be taken
50

The instances used in fractional Knapsack are

Weight		10	20	30	
Profit		60	100	120	
Instance	1	1	0.666667	

The maximum profit is 240
The instances used in 0-1 Knapsack are

Weight		10	20	30	
Profit		60	100	120	
Instance	1	1	0	

The maximum profit is 160


//TIME COMPLEXITY:

For N = 1: time is a constant (denoted by 1)

Otherwise: time to mergesort N elements = time to mergesort N/2 elements plus
time to merge two arrays each N/2 elements.

Time to merge two arrays each N/2 elements is linear, i.e. N

Thus we have:

(1) T(1) = 1

(2) T(N) = 2T(N/2) + N

Next we will solve this recurrence relation. First we divide (2) by N:

(3) T(N) / N = T(N/2) / (N/2) + 1

N is a power of two, so we can write

(4) T(N/2) / (N/2) = T(N/4) / (N/4) +1
(5) T(N/4) / (N/4) = T(N/8) / (N/8) +1

(6) T(N/8) / (N/8) = T(N/16) / (N/16) +1

(7) ……
(8) T(2) / 2 = T(1) / 1 + 1

Now we add equations (3) through (8) : the sum of their left-hand sides
will be equal to the sum of their right-hand sides:

T(N) / N + T(N/2) / (N/2) + T(N/4) / (N/4) + … + T(2)/2 =

T(N/2) / (N/2) + T(N/4) / (N/4) + ….+ T(2) / 2 + T(1) / 1 + LogN

(LogN is the sum of 1s in the right-hand sides)

After crossing the equal term, we get

(9) T(N)/N = T(1)/1 + LogN

T(1) is 1, hence we obtain

(10) T(N) = N + NlogN = O(NlogN)

Hence the complexity of the MergeSort algorithm is O(NlogN).

Along with mergesort, one loop of n iterations is present.
As only the dominant factor is considered, the time complexity for the rest part can be ignored.
